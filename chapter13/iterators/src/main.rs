/*

- Iterators are lazy in Rust: they have no effect until you call the methods that use them.
- All iterators implement a trait named Iterator that is defined in the standard library.
- The Iterator trait only requires implementors to define one method: the next method,
which returns one item of the iterator at a time wrapped in Some and, when iteration is
over, returns None.

- The values we get from the calls to next are immutable references to the values in the vector.
- The iter method produces an iterator over immutable references.
- To take ownership of v1 and returns owned values, we can call into_iter instead of iter. - To iterate over mutable references, we can call iter_mut instead of iter.

- Methods that call next are called consuming adaptors, because calling them uses up the iterator. (sum)

- Iterator adaptors (map) are methods defined on the Iterator trait that donâ€™t consume the
iterator. They produce different iterators by changing some aspect of the original iterator.

- You can chain multiple calls to iterator adaptors to perform complex actions in a
readable way.
- Since iterators are lazy, you have to call one of the consuming adaptor methods to get
results from calls to iterator adaptors.



*/

fn main() {
    // Creating an iterator in a variable.
    let v1 = vec![1, 2, 3];
    let v1_iter = v1.iter();

    // Use their values with for loop.
    // No need to make v1_iter mutable when we used a for loop.
    // The loop took ownership of v1_iter and made it mutable behind the scenes.
    for val in v1_iter {
        println!("Got: {}", val);
    }

    // Iterator adaptor
    let v1: Vec<i32> = vec![1, 2, 3];
    v1.iter().map(|x| x + 1); // It never gets called, unused (lazy)

    // The new iterator generated by map needs to be consumed (here, collect into a vector).
    // map is normally used with closures
    let v1: Vec<i32> = vec![1, 2, 3];
    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
    assert_eq!(v2, vec![2, 3, 4]);
}
